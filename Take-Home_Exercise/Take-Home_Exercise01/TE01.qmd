---
title: "Take-Home Exercise 01"
author: "Chun-Han"
date: "February 2, 2026"
date-modified: "last-modified"
execute: 
  eval: true
  echo: true
  warning: false
  freeze: true
---

## Overview

This report analyzes income inequality among rural informal labourers in Northern Vietnam. Leveraging tidyverse for data wrangling and ggplot2 for visual analytics, we address key socio-economic questions through four progressive lenses:

1.  **Macro Context**: Demographics and income distribution patterns.

2.  **Structural Gaps**: The influence of ethnicity, gender, and livelihood diversity.

3.  **Micro Influencers**: Returns on education, vocational training, and credit access.

4.  **Social Outlook**: Linking policy priorities to rural development perceptions.

## 1 Getting Started

### 1.1 Installing and loading the packages

| Library | Description |
|----------------|--------------------------------------------------------|
| tidyverse | A collection of core packages designed for data science, used extensively for data preparation and wrangling. |
| readxl | Allows R to read Excel files (.xlsx). |
| patchwork | For arranging multiple ggplot2 figures into a composite figure. |
| ggthemes | Provides extra themes, geoms, and scales for ggplot2. |
| scales | Supplies scale functions and tools for customizing axes, labels, and legends in ggplot2. |
| ggdist | An extension of ggplot2 for visualising distributions and uncertainty, useful for half-violin or raincloud plots. |

```{r}
pacman::p_load(tidyverse, readxl, patchwork, ggthemes, scales, ggdist)
```

### 1.2 Data import

[The dataset](https://www.sciencedirect.com/science/article/pii/S235234092100576X) used in this study is derived from a socio-economic survey of 725 informal labourers across five provinces in the Northern Mountainous Region of Vietnam. The data consists of 725 observations and 30 variables, categorized into six key dimensions: Characteristics (C), Income Types (T), Impact Factors (F), Living Conditions (L), Policy Opinions (P), and Social Assessments (A).

```{r}
raw_df <- read_excel("data/Upload for elsiver.xlsx",
                     sheet = 1,
                     na = c("", "NA"))
```

### 1.3 Filtering data for selected variables

```{r}
selected_df <- raw_df %>%
  select(
    CPRO, CGEN, CRAC, CJOB, CQUI,        
    TEIN, TAIN, TSII, TOIN,              
    FEDU, FVTP, FCRA, FTAP,              
    LWDA,                                
    starts_with("PPO"),                  
    ARO4,                                
    starts_with("LHO")                
  )

```

### 1.4 Data Preprocessing

#### 1.4.1 Checking Duplicate Rows

Using the `duplicated()` function to see whether there are duplicate entries in the data.

```{r}
raw_dup <- raw_df[duplicated(raw_df), ]
raw_dup
```

```{r}
sel_dup <- selected_df[duplicated(selected_df), ]
sel_dup
```

::: callout-note
**Interpretation of duplicates**

We checked duplicates at two levels:

-   `raw_df`: duplicates here indicate **exactly repeated records across all variables** (data-entry duplication).
-   `selected_df`: duplicates here may arise because, after selecting a subset of variables, **multiple respondents can share identical profiles** on the selected features (projection duplicates).

Since this is a survey dataset **without respondent IDs**, and projection duplicates can legitimately reflect homogeneous socio-economic profiles in the target population, **we retain all records** to avoid artificially altering the sample distribution.
:::

#### 1.4.2 Checking Missing Value

```{r}
na_summary <- selected_df %>%
  summarise(across(everything(), ~sum(is.na(.)))) %>%
  pivot_longer(everything(),
               names_to = "variable",
               values_to = "na_count") %>%
  arrange(desc(na_count))

na_summary
```

#### 1.4.3 Renaming Columns and Transforming Feature

For categorical grouping variables, missing values are retained as an explicit category ("Unknown") to preserve the full income distribution and avoid unnecessary sample loss.

```{r}
clean_df <- selected_df %>%
  
  # 1) Listwise deletion on core income metric
  filter(!is.na(TEIN)) %>%
  
  # 2) Rename columns first (more readable downstream)
  rename(
    total_income         = TEIN,
    agri_income          = TAIN,
    service_industry_inc = TSII,
    other_income         = TOIN,
    working_days         = LWDA,
    policy_training      = PPO1,
    policy_agri_chain    = PPO2,
    policy_healthcare    = PPO3,
    policy_elderly_care  = PPO4,
    policy_urban_jobs    = PPO5,
    wellbeing_improve    = ARO4,
    house_cottage        = LHO1,
    house_roofed         = LHO2,
    house_solid          = LHO3,
    house_buildings      = LHO4
  ) %>%
  
  # 3) Binary indicators: NA -> 0
  mutate(across(starts_with("house_"),
                ~replace_na(as.numeric(.), 0))) %>%
  
  # 4) PPO series: NA -> "Not Answered"
  mutate(across(starts_with("policy_"),
                ~replace_na(as.character(.), "Not Answered"))) %>%
  
  # 5) Recode coded variables into factors (and explicitly keep missing as "Unknown")
  mutate(
    province = factor(CPRO, levels = 1:5,
                      labels = c("Tuyen Quang", "Quang Ninh", "Ha Giang", "Yen Bai", "Bac Giang")),
    
    gender = factor(CGEN, levels = c(1, 2),
                    labels = c("Male", "Female")) |> 
      forcats::fct_explicit_na("Unknown"),
    
    race = factor(CRAC, levels = c(1, 2),
                  labels = c("Kinh", "Minority")) |>
      forcats::fct_explicit_na("Unknown"),
    
    job_type = factor(CJOB, levels = c(1, 2, 3),
                      labels = c("Agricultural", "Service/Industrial", "Other")) |>
      forcats::fct_explicit_na("Unknown"),
    
    # Keep income group order from lowest -> top (useful for plots)
    income_group = factor(CQUI, levels = c(5, 4, 3, 2, 1),
                          labels = c("Lowest", "Second", "Middle", "Fourth", "Top")) |>
      forcats::fct_explicit_na("Unknown"),
    
    education = factor(FEDU, levels = c(0, 1, 2, 3),
                       labels = c("Primary", "Lower secondary", "Upper secondary", "Other")) |>
      forcats::fct_explicit_na("Unknown"),
    
    training_status = factor(FVTP, levels = c(1, 2),
                             labels = c("Short course", "Long course")) |>
      forcats::fct_explicit_na("Unknown"),
    
    credit_status = factor(FCRA, levels = c(1, 2),
                           labels = c("Inaccessible", "Accessible")) |>
      forcats::fct_explicit_na("Unknown"),
    
    tech_level = factor(FTAP, levels = c(1, 2),
                        labels = c("Low", "Adequate")) |>
      forcats::fct_explicit_na("Unknown"),
    
    # Convert binary house indicators to factor labels
    across(starts_with("house_"),
           ~factor(.x, levels = c(0, 1), labels = c("No", "Yes"))),
    
    # Recode wellbeing (ARO4) if it's numeric 1-5; otherwise keep Unknown
    wellbeing_improve = replace_na(as.character(wellbeing_improve), "Unknown"),
    wellbeing_improve = case_when(
      wellbeing_improve == "1" ~ "Strongly Disagree",
      wellbeing_improve == "2" ~ "Disagree",
      wellbeing_improve == "3" ~ "Neutral",
      wellbeing_improve == "4" ~ "Agree",
      wellbeing_improve == "5" ~ "Strongly Agree",
      TRUE ~ "Unknown"
    ) %>% factor(levels = c("Strongly Disagree","Disagree","Neutral","Agree","Strongly Agree","Unknown")),
    
    # PPO recode (keep Not Answered)
    across(starts_with("policy_"), ~case_when(
      .x == "1" ~ "Strongly Disagree",
      .x == "2" ~ "Disagree",
      .x == "3" ~ "Neutral",
      .x == "4" ~ "Agree",
      .x == "5" ~ "Strongly Agree",
      .x == "Not Answered" ~ "Not Answered",
      TRUE ~ "Not Answered"
    ) %>% factor(levels = c("Strongly Disagree","Disagree","Neutral","Agree","Strongly Agree","Not Answered"))),
    
    # Feature engineering
    daily_wage = if_else(!is.na(working_days) & working_days > 0,
                         total_income / working_days,
                         NA_real_),
    
    agri_inc_ratio = if_else(total_income > 0, agri_income / total_income, NA_real_),
    service_inc_ratio = if_else(total_income > 0, service_industry_inc / total_income, NA_real_),
    other_inc_ratio = if_else(total_income > 0, other_income / total_income, NA_real_)
  ) %>%
  
  # Drop original coded columns (optional but keeps dataset clean)
  select(-CPRO, -CGEN, -CRAC, -CJOB, -CQUI, -FEDU, -FVTP, -FCRA, -FTAP)

# Final verification
glimpse(clean_df)
```

-   For Likert-scale items (PPO and ARO4), missing responses are treated as non-substantive answers.

-   We label PPO missing values as **"Not Answered"** to distinguish non-response from agreement levels, and recode ARO4 into ordered agreement categories while keeping missing/invalid entries as **"Unknown"**.

## 2 Visualization

### 2.1 Macro Context

#### 2.1.1 Regional Workforce Composition by Ethnicity and Gender

::: panel-tabset
### Plot

```{r}
#| echo: false

plot_data_21 <- clean_df %>%
  count(province, race, gender, name = "count") %>%
  group_by(province) %>%
  mutate(
    prov_total = sum(count),
    percentage = count / prov_total,
    facet_label = paste0(province, " \n(N=", prov_total, ")")
  ) %>%
  ungroup()

ggplot(plot_data_21, aes(x = race, y = percentage, fill = gender)) +
  geom_col(width = 0.7, alpha = 0.9) +
  geom_text(
    aes(label = scales::percent(percentage, accuracy = 1)),
    position = position_stack(vjust = 0.5),
    size = 3,
    color = "white"
  ) +
  facet_wrap(~facet_label, nrow = 1) +
  scale_y_continuous(
    labels = scales::percent_format(accuracy = 1),
    expand = expansion(mult = c(0, 0.05))
  ) +
  scale_fill_manual(
    values = c("Male" = "#547d9d", "Female" = "#d8a437")
  ) +
  labs(
    title = "Workforce Composition by Region",
    subtitle = "Proportional share within each province",
    x = "Ethnic Group",
    y = "Share of Province",
    fill = "Gender"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    legend.position = "top",
    strip.text = element_text(size = 11, face = "bold"),
    axis.text = element_text(size = 10),
    panel.spacing = unit(1.2, "lines")
  )
```

### Code

```{r}
#| eval: false

plot_data_21 <- clean_df %>%
  count(province, race, gender, name = "count") %>%
  group_by(province) %>%
  mutate(
    prov_total = sum(count),
    percentage = count / prov_total,
    facet_label = paste0(province, " \n(N=", prov_total, ")")
  ) %>%
  ungroup()

ggplot(plot_data_21, aes(x = race, y = percentage, fill = gender)) +
  geom_col(width = 0.7, alpha = 0.9) +
  geom_text(
    aes(label = scales::percent(percentage, accuracy = 1)),
    position = position_stack(vjust = 0.5),
    size = 3,
    color = "white"
  ) +
  facet_wrap(~facet_label, nrow = 1) +
  scale_y_continuous(
    labels = scales::percent_format(accuracy = 1),
    expand = expansion(mult = c(0, 0.05))
  ) +
  scale_fill_manual(
    values = c("Male" = "#547d9d", "Female" = "#d8a437")
  ) +
  labs(
    title = "Workforce Composition by Region",
    subtitle = "Proportional share within each province",
    x = "Ethnic Group",
    y = "Share of Province",
    fill = "Gender"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    legend.position = "top",
    strip.text = element_text(size = 11, face = "bold"),
    axis.text = element_text(size = 10),
    panel.spacing = unit(1.2, "lines")
  )
```
:::

**Observation**

This visualization confirms a balanced sampling design across the five provinces, with each region contributing a comparable number of observations. Clear regional differences emerge in ethnic composition: ethnic minorities dominate the informal labour force in Ha Giang, Tuyen Quang, and Yen Bai, whereas Kinh workers represent a larger share in Bac Giang and Quang Ninh. This highlights the strong association between remoteness and minority participation in informal employment.

In contrast, gender composition exhibits a consistent structural imbalance rather than a geographic pattern. Male workers account for the majority of informal labourers across all provinces and ethnic groups, with only modest variation in female participation. These differences occur within an overall male-dominated workforce and do not show systematic spatial variation. This suggests that gender disparities in informal labour participation reflect broader labour market or household-level constraints, while regional variation is more strongly driven by ethnicity and location.

### 2.2 Income Distribution & Inequality

```{r}
#| echo: false

plot_data_22 <- clean_df %>%
  count(income_group) %>%
  mutate(percentage = n / sum(n))

p_quintile <- ggplot(plot_data_22, aes(x = income_group, y = percentage)) +
  geom_col(fill = "#547d9d", alpha = 0.9) +
  geom_text(
    aes(label = scales::percent(percentage, accuracy = 1)),
    vjust = -0.3,
    size = 3.5
  ) +
  scale_y_continuous(
    labels = scales::percent_format(accuracy = 1),
    expand = expansion(mult = c(0, 0.08))
  ) +
  labs(
    title = "Income Quintile Distribution",
    subtitle = "Share of respondents by income group",
    x = "Income Quintile",
    y = "Share of Respondents"
  ) +
  theme_minimal(base_size = 11) +
  theme(
    plot.title = element_text(face = "bold"),
    panel.grid.minor = element_blank()
  )

lorenz_df <- clean_df %>%
  filter(!is.na(total_income), total_income >= 0) %>%
  arrange(total_income) %>%
  mutate(
    cum_pop = row_number() / n(),
    cum_income = cumsum(total_income) / sum(total_income)
  )

lorenz_50 <- lorenz_df %>%
  filter(cum_pop >= 0.5) %>%
  slice(1)

p_lorenz <- ggplot(lorenz_df, aes(x = cum_pop, y = cum_income)) +
  geom_line(color = "#547d9d", linewidth = 1.1) +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed", color = "grey60") +
  geom_point(
    data = lorenz_50,
    aes(x = cum_pop, y = cum_income),
    color = "#d8a437",
    size = 2.8
  ) +
  scale_x_continuous(labels = scales::percent_format(accuracy = 1), limits = c(0, 1)) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1), limits = c(0, 1)) +
  labs(
    title = "Lorenz Curve of Income Distribution",
    subtitle = paste0("Bottom 50% hold ~", scales::percent(lorenz_50$cum_income, accuracy = 1), " of total income"),
    x = "Cumulative Share of Population",
    y = "Cumulative Share of Income"
  ) +
  theme_minimal(base_size = 11) +
  theme(
    plot.title = element_text(face = "bold"),
    panel.grid.minor = element_blank()
  )

(p_quintile | p_lorenz)

```

**Observation**

Income among rural informal labourers is concentrated in the lower-to-middle strata, yet the Lorenz curve shows that income accumulation remains uneven. Most respondents fall within the bottom and middle income quintiles, indicating that low-to-mid income conditions are widespread rather than limited to a small disadvantaged subgroup. However, the Lorenz curve deviates from the line of equality, implying that a relatively smaller share of higher earners holds a disproportionate share of total income. Together, these patterns suggest persistent inequality within an overall low-income population, reflecting structural constraints alongside unequal income capture at the upper tail.

#### 2.2.1 Income Quintile Distribution

::: panel-tabset
### Plot

```{r}
#| echo: false

p_quintile
```

### Code

```{r}
#| eval: false

plot_data_22 <- clean_df %>%
  count(income_group) %>%
  mutate(percentage = n / sum(n))

p_quintile <- ggplot(plot_data_22, aes(x = income_group, y = percentage)) +
  geom_col(fill = "#547d9d", alpha = 0.9) +
  geom_text(
    aes(label = scales::percent(percentage, accuracy = 1)),
    vjust = -0.3,
    size = 3.5
  ) +
  scale_y_continuous(
    labels = scales::percent_format(accuracy = 1),
    expand = expansion(mult = c(0, 0.08))
  ) +
  labs(
    title = "Income Quintile Distribution",
    subtitle = "Share of respondents by income group",
    x = "Income Quintile",
    y = "Share of Respondents"
  ) +
  theme_minimal(base_size = 11) +
  theme(
    plot.title = element_text(face = "bold"),
    panel.grid.minor = element_blank()
  )

p_quintile
```
:::

#### 2.2.2 Lorenz Curve of Income Distribution

::: panel-tabset
### Plot

```{r}
#| echo: false

p_lorenz
```

### Code

```{r}
#| eval: false

lorenz_df <- clean_df %>%
  filter(!is.na(total_income), total_income >= 0) %>%
  arrange(total_income) %>%
  mutate(
    cum_pop = row_number() / n(),
    cum_income = cumsum(total_income) / sum(total_income)
  )

lorenz_50 <- lorenz_df %>%
  filter(cum_pop >= 0.5) %>%
  slice(1)

p_lorenz <- ggplot(lorenz_df, aes(x = cum_pop, y = cum_income)) +
  geom_line(color = "#547d9d", linewidth = 1.1) +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed", color = "grey60") +
  geom_point(
    data = lorenz_50,
    aes(x = cum_pop, y = cum_income),
    color = "#d8a437",
    size = 2.8
  ) +
  scale_x_continuous(labels = scales::percent_format(accuracy = 1), limits = c(0, 1)) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1), limits = c(0, 1)) +
  labs(
    title = "Lorenz Curve of Income Distribution",
    subtitle = paste0("Bottom 50% hold ~", scales::percent(lorenz_50$cum_income, accuracy = 1), " of total income"),
    x = "Cumulative Share of Population",
    y = "Cumulative Share of Income"
  ) +
  theme_minimal(base_size = 11) +
  theme(
    plot.title = element_text(face = "bold"),
    panel.grid.minor = element_blank()
  )

p_lorenz
```
:::

### 2.3 Structural Disparities

```{r}
#| echo: false


pal <- c("Male" = "#547d9d", "Female" = "#d8a437")

df_income <- clean_df %>% 
  filter(!is.na(total_income), total_income >= 0) %>%
  mutate(
    race   = droplevels(race),
    gender = droplevels(gender)
  )

x_max <- as.numeric(quantile(df_income$total_income, 0.95, na.rm = TRUE))

p_rain_split <- ggplot(df_income, aes(x = total_income, y = race, fill = gender)) +
  ggdist::stat_halfeye(
    adjust = 0.65,
    width  = 0.55,
    .width = 0,
    alpha  = 0.55,
    point_colour = NA,
    justification = 0.85,
    position = position_dodge(width = 0.75)
  ) +
  geom_point(
    aes(color = gender),
    position = position_jitterdodge(
      jitter.height = 0.18,
      dodge.width   = 0.75,
      seed          = 2022
    ),
    alpha = 0.22,
    size  = 0.75
  ) +
  scale_fill_manual(values = pal) +
  scale_color_manual(values = pal) +
  scale_x_continuous(
    labels = scales::comma,
    breaks = scales::breaks_pretty(n = 6)
  ) +
  coord_cartesian(xlim = c(0, x_max)) +
  labs(
    title = "Income Spread by Ethnicity and Gender",
    subtitle = "Distributions and individual observations",
    x = "Total Income",
    y = "Ethnic Group",
    fill = "Gender"
  ) +
  theme_minimal(base_size = 11) +
  theme(
    plot.title = element_text(face = "bold"),
    panel.grid.minor = element_blank(),
    legend.position = "top"
  ) +
  guides(color = "none")

p_box_23 <- ggplot(df_income, aes(x = race, y = total_income, fill = gender)) +
  geom_boxplot(width = 0.6, outlier.alpha = 0.25) +
  coord_cartesian(ylim = c(0, 150)) +
  scale_fill_manual(values = pal) +
  labs(
    title = "Income Distribution (Boxplot)",
    subtitle = "Median and IQR by ethnicity and gender",
    x = "Ethnic Group",
    y = "Total Income"
  ) +
  theme_minimal(base_size = 11) +
  theme(
    plot.title = element_text(face = "bold"),
    panel.grid.minor = element_blank(),
    legend.position = "top"
  )

p_density_23 <- ggplot(df_income, aes(x = total_income, fill = gender)) +
  geom_density(alpha = 0.55) +
  facet_wrap(~ race, scales = "free_y") +
  coord_cartesian(xlim = c(0, x_max)) +
  scale_fill_manual(values = pal) +
  labs(
    title = "Within-Group Income Distribution",
    subtitle = "Gender density within each ethnicity",
    x = "Total Income",
    y = "Density"
  ) +
  theme_minimal(base_size = 11) +
  theme(
    plot.title = element_text(face = "bold"),
    panel.grid.minor = element_blank(),
    legend.position = "top"
  )

p_rain_split / (p_box_23 | p_density_23)
```

**Observation**

Most respondents’ total income is concentrated below 100, with distributions tightly clustered in the 20–60 range, indicating generally low income levels across the sample. Clear ethnic disparities emerge: ethnic minority workers exhibit lower median incomes and a left-shifted distribution compared with Kinh workers, suggesting structurally constrained earning capacity rather than isolated poverty. Gender differences are not uniform across groups. Among Kinh workers, male and female income distributions largely overlap, whereas among ethnic minorities, male incomes are more compressed at the lower end, with weaker upper-tail dispersion. Together, these patterns indicate that income inequality is shaped by ethnicity and that gender-based income advantages are conditional on ethnic context, pointing to intersecting structural constraints rather than single-factor effects.

#### 2.3.1 Income Spread (Raincloud)

::: panel-tabset
### Plot

```{r}
#| echo: false

p_rain_split
```

### Code

```{r}
#| eval: false

pal <- c("Male" = "#547d9d", "Female" = "#d8a437")

df_income <- clean_df %>% 
  filter(!is.na(total_income), total_income >= 0) %>%
  mutate(
    race   = droplevels(race),
    gender = droplevels(gender)
  )

x_max <- as.numeric(quantile(df_income$total_income, 0.95, na.rm = TRUE))

p_rain_split <- ggplot(df_income, aes(x = total_income, y = race, fill = gender)) +
  ggdist::stat_halfeye(
    adjust = 0.65,
    width  = 0.55,
    .width = 0,
    alpha  = 0.55,
    point_colour = NA,
    justification = 0.85,
    position = position_dodge(width = 0.75)
  ) +
  geom_point(
    aes(color = gender),
    position = position_jitterdodge(
      jitter.height = 0.18,
      dodge.width   = 0.75,
      seed          = 2022
    ),
    alpha = 0.22,
    size  = 0.75
  ) +
  coord_cartesian(xlim = c(0, x_max)) +
  scale_fill_manual(values = pal) +
  scale_color_manual(values = pal) +
  scale_x_continuous(labels = scales::comma) +
  labs(
    title = "Income Spread by Ethnicity and Gender",
    subtitle = "Distribution shape + individual observations (trimmed to 95th percentile)",
    x = "Total Income",
    y = "Ethnic Group",
    fill = "Gender"
  ) +
  theme_minimal(base_size = 11) +
  theme(
    plot.title = element_text(face = "bold"),
    panel.grid.minor = element_blank(),
    legend.position = "top"
  ) +
  guides(color = "none")

p_rain_split
```
:::

::: callout-note
- To improve readability, the x-axis is trimmed to the 95th percentile using `coord_cartesian()`.

- This keeps the main distribution visible while preventing a small number of extreme incomes from stretching the scale.
:::

#### 2.3.2 Income Distribution (Boxplot)

::: panel-tabset
### Plot

```{r}
#| echo: false

p_box_23
```

### Code

```{r}
#| eval: false

p_box_23 <- ggplot(df_income, aes(x = race, y = total_income, fill = gender)) +
  geom_boxplot(width = 0.6, outlier.alpha = 0.25) +
  coord_cartesian(ylim = c(0, 150)) +
  scale_fill_manual(values = pal) +
  labs(
    title = "Income Distribution (Boxplot)",
    subtitle = "Median and IQR highlighted (zoomed to 0–150)",
    x = "Ethnic Group",
    y = "Total Income"
  ) +
  theme_minimal(base_size = 11) +
  theme(
    plot.title = element_text(face = "bold"),
    panel.grid.minor = element_blank(),
    legend.position = "top"
  )

p_box_23
```
:::

::: callout-note
- The y-axis is zoomed to 0–150 via `coord_cartesian()` to highlight differences in the median and IQR.

- Outliers are still present in the dataset; they are only de-emphasized visually to avoid compressing the box region.
:::


#### 2.3.3 Within-Group Income Distribution (Density)

::: panel-tabset
### Plot

```{r}
#| echo: false

p_density_23
```

### Code

```{r}
#| eval: false

p_density_23 <- ggplot(df_income, aes(x = total_income, fill = gender)) +
  geom_density(alpha = 0.55) +
  facet_wrap(~ race, scales = "free_y") +
  coord_cartesian(xlim = c(0, x_max)) +
  scale_fill_manual(values = pal) +
  labs(
    title = "Within-Group Income Distribution",
    subtitle = "Gender density within each ethnic group (trimmed to 95th percentile)",
    x = "Total Income",
    y = "Density"
  ) +
  theme_minimal(base_size = 11) +
  theme(
    plot.title = element_text(face = "bold"),
    panel.grid.minor = element_blank(),
    legend.position = "top"
  )

p_density_23
```
:::

::: callout-note
- Density plots are faceted by ethnicity with `scales = "free_y"` so each group’s distribution shape is readable.

- The x-axis is trimmed to the 95th percentile, focusing attention on the dominant income range.
:::


### 2.4 Income Composition

```{r}
#| echo: false

quintile_order <- c("Unknown", "Lowest", "Second", "Middle", "Fourth", "Top")

pal_src <- c(
  "Agriculture" = "#6b8ba4",
  "Service"     = "#d8a437",
  "Other"       = "#f1e3c4"
)

df_24 <- clean_df %>%
  filter(!is.na(income_group), !is.na(total_income), total_income > 0) %>%
  mutate(income_group = forcats::fct_relevel(income_group, quintile_order))

comp_df <- df_24 %>%
  transmute(
    income_group,
    Agriculture = agri_inc_ratio,
    Service     = service_inc_ratio,
    Other       = other_inc_ratio
  ) %>%
  pivot_longer(
    cols = c(Agriculture, Service, Other),
    names_to = "income_source",
    values_to = "share"
  ) %>%
  group_by(income_group, income_source) %>%
  summarise(share = mean(share, na.rm = TRUE), .groups = "drop") %>%
  group_by(income_group) %>%
  mutate(share = share / sum(share, na.rm = TRUE)) %>%   # ensure =100%
  ungroup()

p_comp <- ggplot(comp_df, aes(x = income_group, y = share, fill = income_source)) +
  geom_col(width = 0.7, alpha = 0.95) +
  geom_text(
    aes(label = ifelse(share >= 0.10, scales::percent(share, accuracy = 1), "")),
    position = position_stack(vjust = 0.5),
    color = "white",
    size = 3
  ) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
  scale_fill_manual(values = pal_src) +
  labs(
    title = "Income Source Composition by Quintile",
    subtitle = "Higher quintiles rely more on service and other non-agricultural income",
    x = "Income Quintile",
    y = "Share of Total Income",
    fill = "Income Source"
  ) +
  theme_minimal(base_size = 11) +
  theme(
    plot.title = element_text(face = "bold"),
    panel.grid.minor = element_blank(),
    legend.position = "top"
  )

mean_df <- df_24 %>%
  group_by(income_group) %>%
  summarise(
    mean_income = mean(total_income, na.rm = TRUE),
    se = sd(total_income, na.rm = TRUE) / sqrt(n()),
    .groups = "drop"
  ) %>%
  mutate(
    ci_low  = mean_income - 1.96 * se,
    ci_high = mean_income + 1.96 * se
  )

p_mean <- ggplot(mean_df, aes(x = income_group, y = mean_income)) +
  geom_col(fill = "#547d9d", width = 0.6, alpha = 0.9) +
  geom_errorbar(aes(ymin = ci_low, ymax = ci_high), width = 0.2) +
  scale_y_continuous(labels = scales::comma) +
  labs(
    title = "Average Total Income by Quintile",
    subtitle = "Mean income with 95% confidence intervals",
    x = "Income Quintile",
    y = "Mean Total Income"
  ) +
  theme_minimal(base_size = 11) +
  theme(
    plot.title = element_text(face = "bold"),
    panel.grid.minor = element_blank()
  )

p_comp / p_mean
```

**Observation**

While higher income quintiles mechanically exhibit higher average income, the key distinction lies in income composition. Lower quintiles depend predominantly on agricultural income, with limited diversification across income sources. As income levels rise, the share of service and other non-agricultural income increases substantially, alongside a marked rise in average total income. This pattern suggests that upward income mobility is associated with structural shifts in livelihood strategies, rather than proportional increases within the same income source.

#### 2.4.1 Income Source Composition by Quintile

::: panel-tabset
### Plot

```{r}
#| echo: false

p_comp
```

### Code

```{r}
#| eval: false

pal_src <- c(
  "Agriculture" = "#547d9d",
  "Service"     = "#d8a437",
  "Other"       = "#f3e4c7"
)

quintile_order <- c("Unknown", "Lowest", "Second", "Middle", "Fourth", "Top")

comp_df <- clean_df %>%
  filter(!is.na(total_income), total_income > 0) %>%
  mutate(income_group = forcats::fct_relevel(income_group, quintile_order)) %>%
  transmute(
    income_group,
    Agriculture = agri_inc_ratio,
    Service     = service_inc_ratio,
    Other       = other_inc_ratio
  ) %>%
  pivot_longer(
    cols = c("Agriculture","Service","Other"),
    names_to = "source",
    values_to = "share"
  ) %>%
  group_by(income_group, source) %>%
  summarise(share = mean(share, na.rm = TRUE), .groups = "drop") %>%
  group_by(income_group) %>%
  mutate(share = share / sum(share, na.rm = TRUE)) %>%
  ungroup()

p_comp <- ggplot(comp_df, aes(x = income_group, y = share, fill = source)) +
  geom_col(width = 0.75, alpha = 0.95) +
  geom_text(
    aes(label = scales::percent(share, accuracy = 1)),
    position = position_stack(vjust = 0.5),
    color = "white",
    size = 3.4
  ) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
  scale_fill_manual(values = pal_src) +
  labs(
    title = "Income Source Composition by Income Quintile",
    subtitle = "Higher quintiles show increasing reliance on non-agricultural income",
    x = "Income Quintile",
    y = "Share of Total Income",
    fill = "Income Source"
  ) +
  theme_minimal(base_size = 11) +
  theme(
    plot.title = element_text(face = "bold"),
    panel.grid.minor = element_blank(),
    legend.position = "top"
  )

p_comp
```
:::

::: callout-note
This figure uses a 100% stacked bar (each bar sums to 100%) to compare income structure across quintiles. Values are based on average income shares (ratios) rather than raw income levels, so the focus is on composition, not magnitude.
:::

#### 2.4.2 Average Total Income by Quintile

::: panel-tabset
### Plot

```{r}
#| echo: false

p_mean
```

### Code

```{r}
#| eval: false

quintile_order <- c("Unknown", "Lowest", "Second", "Middle", "Fourth", "Top")

mean_df <- df_24 %>%
  group_by(income_group) %>%
  summarise(
    mean_income = mean(total_income, na.rm = TRUE),
    se = sd(total_income, na.rm = TRUE) / sqrt(n()),
    .groups = "drop"
  ) %>%
  mutate(
    ci_low  = mean_income - 1.96 * se,
    ci_high = mean_income + 1.96 * se
  )

p_mean <- ggplot(mean_df, aes(x = income_group, y = mean_income)) +
  geom_col(fill = "#547d9d", width = 0.6, alpha = 0.9) +
  geom_errorbar(aes(ymin = ci_low, ymax = ci_high), width = 0.2) +
  scale_y_continuous(labels = scales::comma) +
  labs(
    title = "Average Total Income by Quintile",
    subtitle = "Mean income with 95% confidence intervals",
    x = "Income Quintile",
    y = "Mean Total Income"
  ) +
  theme_minimal(base_size = 11) +
  theme(
    plot.title = element_text(face = "bold"),
    panel.grid.minor = element_blank()
  )

p_mean
```
:::

::: callout-note
Error bars show 95% confidence intervals of the mean, computed as *mean ± 1.96 × SE*. This chart complements the composition plot by showing income magnitude, addressing the limitation that “high share” does not necessarily imply “high income”.
:::

### 2.5 Micro-Level Drivers of Income and Productivity

```{r}
#| echo: false

df_25 <- clean_df %>%
  filter(
    !is.na(total_income),
    education != "Unknown",
    training_status != "Unknown",
    !is.na(daily_wage),
    daily_wage > 0,
    working_days > 0,
    tech_level != "Unknown",
    job_type != "Unknown"
  )

y99_wage <- as.numeric(quantile(df_25$daily_wage, 0.99, na.rm = TRUE))
x99_days <- as.numeric(quantile(df_25$working_days, 0.99, na.rm = TRUE))


theme_25 <- theme_minimal(base_size = 10) +
  theme(
    plot.title = element_text(face = "bold", size = 11),
    plot.subtitle = element_text(size = 9),
    axis.title.x = element_text(size = 9, margin = margin(t = 10)),
    axis.title.y = element_text(size = 9, margin = margin(r = 10)),
    axis.text = element_text(size = 8),
    legend.position = "bottom",
    panel.grid.minor = element_blank()
  )

pal_train <- c(
  "Short course" = "#547d9d",
  "Long course"  = "#d8a437"
)

pal_tech <- c(
  "Low"      = "#547d9d",
  "Adequate" = "#d8a437"
)

pal_job <- c(
  "Agricultural"      = "#547d9d",
  "Service/Industrial"= "#d8a437",
  "Other"             = "#d9c2d3"
)

y99_wage <- as.numeric(quantile(df_25$daily_wage, 0.99, na.rm = TRUE))
x99_days <- as.numeric(quantile(df_25$working_days, 0.99, na.rm = TRUE))

# 3. 設定緊湊主題 (theme)
theme_25_compact <- theme_minimal(base_size = 10) +
  theme(
    plot.title = element_text(face = "bold", size = 12, margin = margin(b = 5)),
    plot.subtitle = element_text(size = 9, margin = margin(b = 10)),
    axis.title.x = element_text(size = 9, margin = margin(t = 5)),
    axis.title.y = element_text(size = 9, margin = margin(r = 5)),
    axis.text = element_text(size = 8),
    legend.position = "bottom",
    panel.grid.minor = element_blank(),
    plot.margin = margin(5, 5, 5, 5) 
  )

p_edu_train <- ggplot(df_25, aes(x = education, y = total_income, fill = training_status)) +
  geom_boxplot(width = 0.65, outlier.alpha = 0.3) +
  scale_x_discrete(guide = guide_axis(n.dodge = 2)) + 
  scale_y_continuous(labels = scales::comma) + 
  scale_fill_manual(values = pal_train) +
  labs(title = "Income by Education & Training", x = "Education", y = "Income", fill = "Training") +
  theme_25_compact

edu_mean <- df_25 %>%
  group_by(education) %>%
  summarise(
    n = n(),
    mean_income = mean(total_income, na.rm = TRUE),
    se = sd(total_income, na.rm = TRUE) / sqrt(n),
    .groups = "drop"
  ) %>%
  mutate(
    ci_low  = mean_income - 1.96 * se,
    ci_high = mean_income + 1.96 * se
  )

p_edu_ci <- ggplot(edu_mean, aes(x = education, y = mean_income)) +
  geom_col(fill = "#547d9d", alpha = 0.9, width = 0.6) +
  geom_errorbar(aes(ymin = ci_low, ymax = ci_high), width = 0.15) +
  scale_x_discrete(guide = guide_axis(n.dodge = 2)) + 
  scale_y_continuous(labels = scales::comma) +
  labs(title = "Average Income by Education", x = "Education", y = "Mean Income") +
  theme_25_compact


p_job <- ggplot(df_25, aes(x = working_days, y = daily_wage, color = job_type)) +
  geom_point(alpha = 0.3, size = 1) +
  geom_smooth(method = "lm", se = FALSE, linewidth = 0.8) +
  coord_cartesian(xlim = c(0, x99_days), ylim = c(0, y99_wage)) +
  scale_color_manual(values = pal_job) +
  labs(title = "Wage vs Days (Job Type)", x = "Days", y = "Daily Wage", color = "Job") +
  theme_25_compact

p_tech <- ggplot(df_25, aes(x = working_days, y = daily_wage, color = tech_level)) +
  geom_point(alpha = 0.3, size = 1) +
  geom_smooth(method = "lm", se = FALSE, linewidth = 0.8) +
  coord_cartesian(xlim = c(0, x99_days), ylim = c(0, y99_wage)) +
  scale_color_manual(values = pal_tech) +
  labs(title = "Wage vs Days (Tech)", x = "Days", y = "Daily Wage", color = "Tech") +
  theme_25_compact

(p_edu_train | p_edu_ci) / (p_job | p_tech) + 
  plot_layout(guides = "collect") & 
  theme(legend.position = "bottom")
```

**Observation**

Income dispersion increases with education level and training intensity. Higher education groups, especially those with long-course training, display not only higher mean income but also wider income distributions driven by an expanded upper tail. Training therefore raises income in a heterogeneous manner rather than uniformly benefiting all workers.

The daily wage analysis clarifies the mechanism behind this pattern. Daily wages decline as working days increase, suggesting diminishing returns to labor intensity in informal work. However, service and industrial jobs consistently offer higher daily wages than agricultural work, and adequate technology access further lifts productivity per day. These results indicate that higher income is achieved not by working more days, but by accessing higher-productivity jobs and technologies.

#### 2.5.1 Income by Education & Training (Boxplot)

::: panel-tabset
### Plot

```{r}
#| echo: false

p_edu_train

```

### Code

```{r}
#| eval: false

p_edu_train <- ggplot(df_25, aes(x = education, y = total_income, fill = training_status)) +
  geom_boxplot(width = 0.65, outlier.alpha = 0.18) +
  coord_cartesian(ylim = c(0, y99_inc), clip = "off") +
  scale_x_discrete(guide = guide_axis(n.dodge = 2)) +
  scale_fill_manual(values = pal_train) +
  labs(
    title = "Income by Education & Training",
    subtitle = "Wider spread at higher levels",
    x = "Education",
    y = "Total Income",
    fill = "Training"
  ) +
  theme_25

p_edu_train
```
:::

#### 2.5.2 Average Income by Education (Mean + 95% CI)

::: panel-tabset
### Plot

```{r}
#| echo: false

p_edu_ci

```

### Code

```{r}
#| eval: false

edu_mean <- df_25 %>%
  group_by(education) %>%
  summarise(
    mean_income = mean(total_income, na.rm = TRUE),
    se = sd(total_income, na.rm = TRUE) / sqrt(n()),
    .groups = "drop"
  ) %>%
  mutate(
    ci_low  = mean_income - 1.96 * se,
    ci_high = mean_income + 1.96 * se
  )

p_edu_ci <- ggplot(edu_mean, aes(x = education, y = mean_income)) +
  geom_col(fill = "#547d9d", alpha = 0.9, width = 0.65) +
  geom_errorbar(aes(ymin = ci_low, ymax = ci_high), width = 0.2) +
  coord_cartesian(clip = "off") +
  scale_x_discrete(guide = guide_axis(n.dodge = 2)) +
  scale_y_continuous(labels = scales::comma) +
  labs(
    title = "Average Income by Education",
    subtitle = "Mean (95% CI)",
    x = "Education",
    y = "Mean Income"
  ) +
  theme_25

p_edu_ci
```
:::

#### 2.5.3 Daily Wage vs Working Days (Job Type)

::: panel-tabset
### Plot

```{r}
#| echo: false

p_job

```

### Code

```{r}
#| eval: false

p_job <- ggplot(df_25, aes(x = working_days, y = daily_wage, color = job_type)) +
  geom_point(alpha = 0.8, size = 1.4) +
  geom_smooth(method = "lm", se = FALSE, linewidth = 0.85) +
  coord_cartesian(xlim = c(0, x99_days), ylim = c(0, y99_wage), clip = "off") +
  scale_x_continuous(breaks = scales::breaks_pretty(n = 5)) +
  scale_color_manual(values = pal_job) +
  labs(
    title = "Daily Wage vs Working Days",
    subtitle = "Higher wage in non-farm jobs",
    x = "Working Days",
    y = "Daily Wage",
    color = "Job"
  ) +
  theme_25

p_job
```
:::

#### 2.5.4 Daily Wage vs Working Days (Technology)

::: panel-tabset
### Plot

```{r}
#| echo: false

p_tech

```

### Code

```{r}
#| eval: false

p_tech <- ggplot(df_25, aes(x = working_days, y = daily_wage, color = tech_level)) +
  geom_point(alpha = 0.8, size = 1.4) +
  geom_smooth(method = "lm", se = FALSE, linewidth = 0.85) +
  coord_cartesian(xlim = c(0, x99_days), ylim = c(0, y99_wage), clip = "off") +
  scale_x_continuous(breaks = scales::breaks_pretty(n = 5)) +
  scale_color_manual(values = pal_tech) +
  labs(
    title = "Daily Wage vs Working Days",
    subtitle = "Tech lifts wage per day",
    x = "Working Days",
    y = "Daily Wage",
    color = "Tech"
  ) +
  theme_25

p_tech
```
:::
