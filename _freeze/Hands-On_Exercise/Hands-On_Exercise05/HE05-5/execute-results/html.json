{
  "hash": "aae1c5edf4afedee33512bef00300534",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Hands-On Exercise 05-5\"\nauthor: \"Chun-Han\"\ndate: \"February 8, 2026\"\ndate-modified: \"last-modified\"\nexecute: \n  eval: true\n  echo: true\n  warning: false\n  freeze: true\n---\n\n## Overview\n\nIn this hands-on exercise, you will gain hands-on experiences on designing treemap using appropriate R packages. The hands-on exercise consists of three main section. First, you will learn how to manipulate transaction data into a treemap strcuture by using selected functions provided in **dplyr** package. Then, you will learn how to plot static **treemap** by using treemap package. In the third section, you will learn how to design interactive treemap by using **d3treeR** package.\n\n## 1 Getting Started\n\n### 1.1 Installing and Launching R Packages\n\nBefore we get started, you are required to check if **treemap** and **tidyverse** pacakges have been installed in you R.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(treemap, treemapify, tidyverse) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\npackage 'gridBase' successfully unpacked and MD5 sums checked\npackage 'igraph' successfully unpacked and MD5 sums checked\npackage 'treemap' successfully unpacked and MD5 sums checked\n\nThe downloaded binary packages are in\n\tC:\\Users\\88696\\AppData\\Local\\Temp\\RtmpWSl3uW\\downloaded_packages\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\npackage 'png' successfully unpacked and MD5 sums checked\npackage 'jpeg' successfully unpacked and MD5 sums checked\npackage 'shades' successfully unpacked and MD5 sums checked\npackage 'gridtext' successfully unpacked and MD5 sums checked\npackage 'ggfittext' successfully unpacked and MD5 sums checked\npackage 'svglite' successfully unpacked and MD5 sums checked\npackage 'treemapify' successfully unpacked and MD5 sums checked\n\nThe downloaded binary packages are in\n\tC:\\Users\\88696\\AppData\\Local\\Temp\\RtmpWSl3uW\\downloaded_packages\n```\n\n\n:::\n:::\n\n\n### 1.2 Data Wrangling\n\nIn this exercise, REALIS2018.csv data will be used. This dataset provides information of private property transaction records in 2018. The dataset is extracted from REALIS portal (https://spring.ura.gov.sg/lad/ore/login/index.cfm) of Urban Redevelopment Authority (URA).\n\n#### 1.2.1 Importing the data set\n\nIn the code chunk below, read_csv() of **readr** is used to import realis2018.csv into R and parsed it into tibble R data.frame format.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrealis2018 <- read_csv(\"data/realis2018.csv\")\n```\n:::\n\n\nThe output tibble data.frame is called realis2018.\n\n#### 1.2.2 Data Wrangling and Manipulation\n\nThe data.frame realis2018 is in trasaction record form, which is highly disaggregated and not appropriate to be used to plot a treemap. In this section, we will perform the following steps to manipulate and prepare a data.frtame that is appropriate for treemap visualisation:\n\n- group transaction records by Project Name, Planning Region, Planning Area, Property Type and Type of Sale, and\n\n- compute Total Unit Sold, Total Area, Median Unit Price and Median Transacted Price by applying appropriate summary statistics on No. of Units, Area (sqm), Unit Price ($ psm) and Transacted Price ($) respectively.\n\nTwo key verbs of **dplyr** package, namely: group_by() and summarize() will be used to perform these steps.\n\ngroup_by() breaks down a data.frame into specified groups of rows. When you then apply the verbs above on the resulting object they’ll be automatically applied “by group”.\n\nGrouping affects the verbs as follows:\n\n- grouped select() is the same as ungrouped select(), except that grouping variables are always retained.\n\n- grouped arrange() is the same as ungrouped; unless you set .by_group = TRUE, in which case it orders first by the grouping variables.\n\n- mutate() and filter() are most useful in conjunction with window functions (like rank(), or min(x) == x). They are described in detail in vignette(“window-functions”).\n\n- sample_n() and sample_frac() sample the specified number/fraction of rows in each group.\n\n- summarise() computes the summary for each group.\n\nIn our case, group_by() will used together with summarise() to derive the summarised data.frame.\n\n:::Recommendation\nStudents who are new to **dplyr** methods should consult Introduction to dplyr before moving on to the next section.\n:::\n\n#### 1.2.3 Grouped summaries without the Pipe\n\nThe code chank below shows a typical two lines code approach to perform the steps.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrealis2018_grouped <- group_by(realis2018, `Project Name`,\n                               `Planning Region`, `Planning Area`, \n                               `Property Type`, `Type of Sale`)\nrealis2018_summarised <- summarise(realis2018_grouped, \n                          `Total Unit Sold` = sum(`No. of Units`, na.rm = TRUE),\n                          `Total Area` = sum(`Area (sqm)`, na.rm = TRUE),\n                          `Median Unit Price ($ psm)` = median(`Unit Price ($ psm)`, na.rm = TRUE), \n                          `Median Transacted Price` = median(`Transacted Price ($)`, na.rm = TRUE))\n```\n:::\n\n\n:::Note\nAggregation functions such as sum() and meadian() obey the usual rule of missing values: if there’s any missing value in the input, the output will be a missing value. The argument na.rm = TRUE removes the missing values prior to computation.\n:::\n\nThe code chunk above is not very efficient because we have to give each intermediate data.frame a name, even though we don’t have to care about it.\n\n#### 1.2.4 Grouped summaries with the pipe\n\nThe code chunk below shows a more efficient way to tackle the same processes by using the pipe, %>%:\n\n:::Recommendation\nTo learn more about pipe, visit this excellent article: Pipes in R Tutorial For Beginners.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrealis2018_summarised <- realis2018 %>% \n  group_by(`Project Name`,`Planning Region`, \n           `Planning Area`, `Property Type`, \n           `Type of Sale`) %>%\n  summarise(`Total Unit Sold` = sum(`No. of Units`, na.rm = TRUE), \n            `Total Area` = sum(`Area (sqm)`, na.rm = TRUE),\n            `Median Unit Price ($ psm)` = median(`Unit Price ($ psm)`, na.rm = TRUE),\n            `Median Transacted Price` = median(`Transacted Price ($)`, na.rm = TRUE))\n```\n:::\n\n\n### 2 Designing Treemap with treemap Package\n\n**treemap** package is a R package specially designed to offer great flexibility in drawing treemaps. The core function, namely: treemap() offers at least 43 arguments. In this section, we will only explore the major arguments for designing elegent and yet truthful treemaps.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}